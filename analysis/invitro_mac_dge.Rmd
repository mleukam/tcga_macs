---
title: "Differential gene expression: _in vitro_ macrophage model"
author: "mleukam"
date: "2019-04-09"
output: workflowr::wflow_html
---

## Introduction

The pupose of this analysis is to find ranked differential gene expression sets for each of a number of experimentally derived macrophage states compared to monocytes. These gene sets will be used for our downstream analyses. 

We are roughly following the methods described in:

> Gubin, Matthew M., Ekaterina Esaulova, Jeffrey P. Ward, Olga N. Malkova, Daniele Runci, Pamela Wong, Takuro Noguchi, et al. 2018. “High-Dimensional Analysis Delineates Myeloid and Lymphoid Compartment Remodeling during Successful Immune-Checkpoint Cancer Therapy.” Cell 175 (4): 1014–30.e19. 

For more details regarding the data source and experimental design, please refer to the [data_download](data_download.html) notebook.

### Setup workspace

Clear workspace prior to analysis and load necessary packages
```{r}
rm(list = ls())
```

```{r packages, message=FALSE, warning=FALSE}
library("tidyverse")
library("GEOquery")
library("lumi")
library("lumiHumanIDMapping")
```

## Data preparation and cleaning

### Read in raw expression data
```{r}
lumi_input <- lumiR("~/tcga_macs/data/GSE46903_non-normalized.txt",
                    sep = "\t",
                    lib.mapping = 'lumiHumanIDMapping',
                    parseColumnName = TRUE,
                    columnNameGrepPattern = list(
                      exprs = 'AVG_Signal', 
                      se.exprs = 'BEAD_STD', 
                      detection = 'Detection', 
                      beadNum = 'Avg_NBEADS')) 
```

### Normalize expression values

 * The input is not a LumiBatch object (e.g. I am not reading in each individual experiment - the original authors already collected into a single output frame), so no background adjustment will be performed.
 * Due to the lack of 'se.exprs' information, 'log2' transformation will be used.
 * Variance Stabilizing Transform method: log2 
 * Normalization method: rsn 
 
```{r message=FALSE, warning=FALSE, results="hide"}
lumi_46903 <- lumiExpresso(lumi_input, 
                         normalize.param = list(method = 'rsn'))

write.exprs(lumi_46903, 
            file = "~/tcga_macs/output/processed_lumi_exprs.txt")
```

### Format and subset metadata
```{r paged.print=TRUE}
# review metadata
show(lumi_46903)
raw_metadata <- pData(phenoData(lumi_46903))
head(raw_metadata)
```

The raw data is labeled with alternate sample names (a 10-digit number followed by underscore and a letter) compared to the GEO records and the sample name in the processed data GSE ExpressionSet object. 

* I will go back to the published pre-processed GSE in the GEO and see if the metadata there can be merged into an expression set with the expression matrix I generated from the raw values.

* [Documentation for manipulating ExpressionSet objects](https://www.bioconductor.org/packages/devel/bioc/vignettes/Biobase/inst/doc/ExpressionSetIntroduction.pdf)

* [Documentation for ExpressionSets created by GEOquery](https://www.bioconductor.org/packages/devel/bioc/vignettes/GEOquery/inst/doc/GEOquery.html#getting-gse-series-matrix-files-as-an-expressionset)

```{r paged.print=TRUE}
# read in previously downloaded GSE containing pre-normalized reads and full metadata
gse46903 <- readRDS("~/tcga_macs/data/gse_46903.rds")
show(pData(phenoData(gse46903[[1]]))[1:20,c(1,6,8)])
```

The 10-digit sample names correspond to experimental conditions, but are stuck in the same column as the description of the experiment.

* [Documentation for working with AnnotatedDataFrame objects](https://www.rdocumentation.org/packages/Biobase/versions/2.32.0/topics/AnnotatedDataFrame)

```{r phenodata, paged.print=TRUE}
# pull phenoData from expression set as an AnnotatedDataFrame
meta46903 <- phenoData(gse46903[[1]])

# get data and annotations separately from AnnotatedDataFrame
meta_data46903 <- pData(meta46903)
anno_data46903 <- varMetadata(meta46903)

# review metadata
class(meta_data46903)
str(meta_data46903)
head(meta_data46903)

# review annotations
class(anno_data46903)
str(anno_data46903)
head(anno_data46903)

# anno_data is pretty useless - just empty variables with matching rownames from pData. Will drop this from further analysis.
```

Format metadata to get raw_id in its own column
```{r format_metadata}
# split "title" column into cell type and raw_id
meta_data46903 <- meta_data46903 %>%
  tidyr::separate(title, 
                  c("cell_type", "raw_id"), 
                  sep = "\\[")

# review results
meta_data46903[1:5, c(1,2)]

# remove trailing closed bracket
# preserve rownames by moving to column
meta_data46903 <- meta_data46903 %>%
  rownames_to_column(var = "geo_id") %>%
  mutate(raw_id = str_remove(raw_id, "]"))

# review results
meta_data46903[1:5, 1:5]
```

Subset metadata
```{r}
# following the Schreiber lab protocol
# use only those macrophages cultured with GMCSF for 72 hours
gmcsf_metadata <- meta_data46903 %>%
  as_tibble() %>%
  filter(grepl("GMCSF", cell_type)) %>%
  filter(grepl("72h", cell_type)) %>%
  print()

# get the raw IDs to select expression profiles later
gmcsf_samples <- gmcsf_metadata %>% pull(raw_id)

# convert back to data.frame and add rownames back in 
# for compatability with expressionset class
gmcsf_metadata <- as.data.frame(gmcsf_metadata)
rownames(gmcsf_metadata) <- gmcsf_metadata$raw_id
gmcsf_metadata[1:5, 1:5]
```


### Subset expression data
Next step is to subset the expression data, and to ensure column names exactly match rownames of phenotype data

Review expression matrix
```{r}
exp_data <- exprs(lumi_46903)
  
# review expression matrix
class(exp_data)
str(exp_data)
exp_data[1:10, 1:3]

# rownames are unique sequence identifiers from lumiHumanIDmapping package
# colnames are 10-digit and letter sample names
# values are log-2 RDS normalized expression values 
# 384 samples and 47462 probes
```

Subset expression matrix
```{r}
# convert to dataframe for subsetting
# use vector of sample names to select cases
exp_data <- exp_data %>%
  as.data.frame() %>%
  rownames_to_column(var = "probe_id") %>%
  dplyr::select(one_of(gmcsf_samples)) %>%
  print()

```
