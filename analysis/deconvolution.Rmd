---
title: "deconvolution"
author: "mleukam"
date: "2020-02-08"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

## Setup

Load packages
```{r}
# analysis packages
library(GEOquery)
library(Biobase)
library(CePa)
library(limma)
library(edgeR)
library(gtools)

# annotation databases
library(annotate)
library(lumiHumanIDMapping)
library(lumiHumanAll.db)

# clustering
library(stats)
library(dendextend)
library(gtools)

# plotting packages
library(VennDiagram)
library(ggpubr)
library(ggsci)
library(viridis)
library(ComplexHeatmap)

# load this last due to masking
library(tidyverse)

```

## Signature matrix: mac spectrum

From: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5998872/

Chen SH, Kuo WY, Su SY, Chung WC, Ho JM, Lu HH, Lin CY. A gene profiling deconvolution approach to estimating immune cell composition from complex tissues. BMC Bioinformatics. 2018 May 8;19(Suppl 4):154. doi: 10.1186/s12859-018-2069-6. PMID: 29745829; PMCID: PMC5998872.

```
To define a set of feature genes for deconvolution, we first eliminate genes that are unsuitable for building model. Two methods were adopted. We use datasets and enrichment score (ES) described in Benita et al. [13] to define genes that expressed in normal tissues by the criteria of ES>0 in more than 5% of observed tissue types. Besides, genes that expressed in cancer cells are collected from cancer cell line encyclopedia [14] in the criteria of log2 transformed expression level>7. The two lists are used as black lists to remove genes expressed in normal tissues and cancer cells from the candidate list.
```

#### Blacklist

For this project, we will use the list of housekeeping genes from: 
"Human housekeeping genes revisited" E. Eisenberg and E.Y. Levanon, Trends in Genetics, 29 (2013) as the first filter. List of housekeeping genes downloaded from author's website: https://www.tau.ac.il/~elieis/HKG/

```{r}
hk_genes <- read_delim("/Volumes/kline-lab/backups/tcga_macs/data/HK_genes.tsv", 
                       delim = "\t", 
                       col_names = c("hgnc_name", "refseq_name"), 
                       trim_ws = TRUE)
hk_genes

blacklist_hk_genes <- hk_genes %>%
  pull(hgnc_name)
head(blacklist_hk_genes)
length(blacklist_hk_genes)
```

Broad Cancer Cell Line Encyclopedia (CCLE) RNAseq gene expression data for 1019 cell lines (raw read counts) downloaded from website: www.broadinstitute.org/ccle. Version last updated: Jan 2, 2019
File moved to data folder

```{r}
# read in as matrix
ccle <- CePa::read.gct("/Volumes/kline-lab/backups/tcga_macs/data/CCLE_RNAseq_genes_counts_20180929.gct")
dim(ccle)

# remove hematopoetic cancer cell lines
ccle_non_heme <- ccle %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_id") %>%
  dplyr::select(!contains("HAEMATOPOIETIC_AND_LYMPHOID_TISSUE")) %>%
  column_to_rownames(var = "gene_id") %>%
  as.matrix()

ccle_non_heme[1:5, 1:5]
str(ccle_non_heme)

# log transform
log2_ccle <- log2(ccle_non_heme)

# read in gene_id to gene_name conversion table
gencode_gtf <- read_tsv("/Volumes/kline-lab/backups/tcga_macs/data/gencode.v22.primary_assembly.annotation.gtf.geneinfo") %>%
  separate(gene_id, into = c("gene_id", "version"), sep = "\\.") %>%
  dplyr::select(gene_id, gene_name) %>%
  print()

# get average gene expression across all cancer cell lines
ccle_log_means <- rowMeans(log2_ccle, na.rm = FALSE, dims = 1)
hist(ccle_log_means)
cancer_genes_high <- ccle_log_means[ccle_log_means > 7]
length(cancer_genes_high)
hist(cancer_genes_high)
head(cancer_genes_high)
blacklist_cancer_genes <- names(cancer_genes_high) %>% 
  enframe() %>%
  dplyr::select(gene_id = value) %>%
  separate(gene_id, into = c("gene_id", "version"), sep = "\\.", remove = TRUE) %>%
  left_join(gencode_gtf) %>%
  dplyr::filter(!is.na(gene_name)) %>%
  pull(gene_name)
head(blacklist_cancer_genes)
```

Make combined blacklist
```{r}
blacklist <- unique(c(blacklist_cancer_genes, blacklist_hk_genes))
length(blacklist)
head(blacklist)
```


#### Filter gene expression data by expression

```{r filter}
# expression set created in clustering.rmd notebook 
# contains normalized expression matrix made from raw illumina beadchip data
# also contains metadata from GEO, treatment assignment, and cluster assignments
# probe ID is unique sequence ID from lumiHumanIDMapping
mac_eset <- readRDS("/Volumes/kline-lab/backups/tcga_macs/output/mac_eset_w_clusters.rds")

# retreive normalized data
dataMatrix <- exprs(mac_eset)

# tidy data
edata_tbl <- dataMatrix %>% 
  as.data.frame() %>%
  rownames_to_column(var = "probeID") %>%
  as_tibble() %>%
  gather(key = "sampleID", value = "intensity", -probeID) %>%
  group_by(sampleID)

# find "valley" in density plot for low value filtering
dplot <- ggplot(edata_tbl, aes(intensity, color = sampleID)) +
  geom_density() + 
  theme(legend.position = "none") +
  geom_vline(xintercept = 5)
dplot

# remove the probes without at least expression value 5 in at least 3 samples 
dataMatrix <- as.data.frame(dataMatrix)
mat_stats <- data.frame(total = apply(dataMatrix, 1, function(x) sum(
      x > 5, na.rm = TRUE)))
keep = which(mat_stats$total >= 3) 

dim(dataMatrix)
selDataMatrix = dataMatrix[keep,]
dim(selDataMatrix)

# gather list of selected probes
probeList <- rownames(selDataMatrix)

```

#### Differential gene expression

Read in macrophage experimental gene expression data
```{r}
# review cluster assignment 
# rename factors to be syntactically valid names
pheno_data <- pData(mac_eset)
pheno_data <- pheno_data %>%
  as.data.frame() %>%
  rownames_to_column(var = "raw_id") %>%
  mutate(adj_cluster = paste0("cluster_", adj_cluster)) %>%
  as_tibble()
pheno_data %>% dplyr::select("raw_id", "treatment", "adj_cluster")

# save for outside use
pheno_data %>% 
  dplyr::select(geo_id, adj_cluster) %>%
  write_csv("/Volumes/kline-lab/backups/tcga_macs/output/geo_id_adj_cluster_lookup_table.csv")
```

From:
Chen SH, Kuo WY, Su SY, Chung WC, Ho JM, Lu HH, Lin CY. A gene profiling deconvolution approach to estimating immune cell composition from complex tissues. BMC Bioinformatics. 2018 May 8;19(Suppl 4):154. doi: 10.1186/s12859-018-2069-6. PMID: 29745829; PMCID: PMC5998872.

```
To select genes that can be the representative features of a cell type, we run the statistical analysis between each two immune cell type pairs. Firstly, the differentially expressed genes (DEGs) are detected using two-sided unequal variance T-test with a significant criterion in q-value <0.3. Secondly, we sort the DEGs of each comparing pair by the absolute value of log fold change of gene expression level in descending order. Third, a top G (G=5 to 100) ranked DEGs are selected from each pair to build a union set of a signature gene list (top G signature gene list) and to derive top G signature matrix, the expression profiles for each top G signature gene list. Condition number [15] which is associated with the linear equation is introduced to define the choice of G and calculated with “kappa” function in R.
```

Development of LM22 from CIBERSORT paper:

Newman AM, Liu CL, Green MR, Gentles AJ, Feng W, Xu Y, Hoang CD, Diehn M, Alizadeh AA. Robust enumeration of cell subsets from tissue expression profiles. Nat Methods. 2015 May;12(5):453-7. doi: 10.1038/nmeth.3337. Epub 2015 Mar 30. PMID: 25822800; PMCID: PMC4739640.
```
We obtained GEP data from the public domain for 22 leukocyte subsets profiled on the HGU133A platform (Supplementary Table 1). Probesets were preprocessed as described above. Significantly differentially expressed genes between each population and all other populations were identified using a two-sided unequal variance t-test. Genes with a q-value < 0.3 (false discovery rate29) were considered significant.

For each leukocyte subset, significant genes were ordered by decreasing fold change compared to other cell subsets, and the top G marker genes from each cell subset were combined into a signature matrix BG. We iterated G from 50 to 200 across all subsets, and retained the signature matrix with the lowest condition number (condition number = 11.4; G = 102; n = 547 distinct genes; Supplementary Table 1).

To prevent genes expressed on non-hematopoietic cell types from confounding deconvolution results, we also used two gene filtration strategies. First, we identified genes with enriched expression in non-hematopoietic cells or tissues using the Gene Enrichment Profiler, an online compendium of diverse cells and tissues profiled on HGU133A (http://xavierlab2.mgh.harvard.edu/EnrichmentProfiler/)30. Gene Enrichment Profiler calculates an enrichment score (ES) for a given gene in a given cell or tissue type based on the sum of linear model coefficients from all pairwise comparisons of that gene with other samples. For each gene and cell or tissue type with ES > 0, we determined the fraction of non-hematopoietic cell or tissue samples in the Gene Enrichment Profiler database, and excluded genes from the signature matrix with a non-hematopoietic fraction >0.05. As a second filtration step, we omitted all genes from further analysis with a mean log2 expression level ≥7 in all non-hematopoietic cancer cell lines profiled in the Cancer Cell Line Encyclopedia (CCLE) (pre-normalized gene expression data were extracted from CCLE_Expression_Entrez_2012-09-29.txt, downloaded from the Broad Institute). We termed the final signature matrix ‘LM22’.
```

Summary of plan:

*Step 1:* Get DEGs of each cluster compaired pairwise to others using limma. Select only those genes with adj.P.Val > 0.3 for each comparison.
*Step 1b:* Apply blacklist and remove housekeeping and cancer genes from list

*Step 2:* Sort each comparison's ttable by logFC in descending order

*Step 3:*. For each G value from 5-100, make an vector of the top G genes from each comparison. Filter the expression matrix for only those genes and create a list of 95 expression matrices (one for each value of G). Calculate the condition number for each expression matrix using the `kappa` function and choose the one with the lowest condition number. This will be the signature gene list.
*Step 3b:* Create the signature gene matrix by averaging columns by each cluster and filtering rows by the signature gene list.

#### Step 1 and 2

```{r}
# set up design matrix
rnames <- pheno_data$raw_id
groups <- as.factor(pheno_data$adj_cluster)
design <- model.matrix(~0 +groups)
colnames(design) <- gsub("groups", "", colnames(design))
rownames(design) <- rnames
design[1:5, 1:5]

# make contrasts
unique_groups <- unique(groups)
unique_groups
# remove cluster 0 (untreated monocytes)
clusternames <- as.character(unique_groups[-1])
clusternames
conts <- as.data.frame(permutations(n = length(clusternames), r = 2, v = clusternames)) %>%
  mutate(cont = paste0(V1, "-", V2)) %>%
  pull(cont)
conts
  
# define contrasts
contr.matrix <- makeContrasts(contrasts = conts, levels = design)
contr.matrix[1:5, 1:5]
dim(contr.matrix)

# fit linear models
fit <- lmFit(selDataMatrix, design)
fit2 <- contrasts.fit(fit, contr.matrix)
fit2 <- eBayes(fit2)

# add gene names
geneSymbol <- annotate::getSYMBOL(probeList, 'lumiHumanAll.db')
geneName <- sapply(lookUp(probeList, 'lumiHumanAll.db', 'GENENAME'),
                   function(x) x[1])
fit2$genes <- data.frame(ID = probeList, 
                         geneSymbol = geneSymbol, 
                         geneName = geneName, 
                         stringsAsFactors = FALSE)

# make a list from 1-42 (length of conts)
numlist <- as.list(seq(1, 42))

# define a function to get toptables and combine in a list
toptabler <- function(numlist, fit){
  topTable(fit2, coef = numlist, 
           adjust.method = "BH",
           sort.by = "none",
           number = Inf)
}

# iterate function over list from 1-42
ttables <- map(numlist, toptabler)
head(ttables[[1]])

# define a funtion to get selected columns from toptables
maketables <- function(ttable_list){
  ttable_list %>%
    dplyr::select(gene_name = geneSymbol, logFC, adj.P.Val) %>%
    as_tibble() %>%
    # select only those with adj.P.Val < 0.3
    dplyr::filter(adj.P.Val < 0.3) %>%
    # filter against the blacklist
    dplyr::filter(!gene_name %in% blacklist) %>%
    # sort by logFC
    arrange(desc(logFC)) %>%
    # remove any unnamed genes
    dplyr::filter(!is.na(gene_name)) %>%
    # remove duplicates
    distinct(gene_name, .keep_all = TRUE)
}

# apply function to list of toptables
tables <- map(ttables, maketables)
tables[[1]]
names(tables) <- conts
head(tables)
# convert to nested dataframe
table_df <- enframe(tables)
table_df
```

#### Step 3

```{r}
# use for loop to slice dataframe column 95 times from 25:200
for (g in 25:200) {
  new_col_name <- paste0("gvalue_", g)
  table_df <- table_df %>%
    mutate(!!sym(new_col_name) := map(value, 
                                      function(x){dplyr::slice(x, 1:{g})}))
}

# get just the g columns and get the gene names
# convert to list
g_genes <- table_df %>%
  dplyr::select(starts_with("gvalue_")) %>%
  mutate_all(~map(., function(x){dplyr::select(x, gene_name)})) %>%
  mutate_all(~map(., unlist)) %>%
  map(., unlist) 
str(g_genes)

# get unique values only
g_genes_union <- map(g_genes, unique)
str(g_genes_union)
```

#### Step 3b

Format expression matrix
```{r}
# rename genes in expression matrix (rownames)
gene_symbol_lookup <- annotate::getSYMBOL(probeList, 'lumiHumanAll.db') %>%
  as.data.frame() %>%
  rownames_to_column(var = "probe_id") %>%
  dplyr::rename("gene_name" = 2) %>%
  as_tibble() %>%
  print()

exp_df <- selDataMatrix %>%
  as.data.frame() %>%
  rownames_to_column(var = "probe_id") %>%
  as_tibble() %>%
  left_join(gene_symbol_lookup) %>%
  dplyr::select(gene_name, everything()) %>%
  # eliminate rows with no gene name
  dplyr::filter(!is.na(gene_name)) %>%
  dplyr::select(-probe_id) %>%
  as.data.frame()

# convert to matrix and set rownames
exp_df[1:5, 1:5]
exp_mat <- exp_df[-1] %>% as.matrix()
exp_mat[1:5, 1:5]
rownames(exp_mat) <- exp_df[,1]
exp_mat[1:5, 1:5]
dim(exp_mat)

# collapse rownames by averaging expression for shared gene symbols
exp_mat <- avereps(exp_mat)
exp_mat[1:5, 1:5]
dim(exp_mat)

# collapse expression by cluster
cluster_lookup <- pheno_data[, c("raw_id", "adj_cluster")]

exp_tbl <- exp_mat %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column(var = "raw_id") %>%
  as_tibble() %>%
  left_join(cluster_lookup) %>%
  dplyr::select(adj_cluster, everything(), -raw_id) %>%
  dplyr::filter(adj_cluster != "cluster_0") %>%
  print()

cluster_matrix <- exp_tbl[-1] %>% as.matrix()
cluster_matrix[1:5, 1:5]
rownames(cluster_matrix) <- pull(exp_tbl, adj_cluster)
cluster_matrix[1:5, 1:5]

# collapse rownames by averaging expression for shared cluster assignment
cluster_matrix <- avereps(cluster_matrix) %>% t()
cluster_matrix[1:5, 1:5]
dim(cluster_matrix)

# convert to df for downstream analysis
cluster_exp_df <- cluster_matrix %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_name") %>%
  dplyr::select(gene_name, cluster_1, cluster_2, cluster_3, cluster_4, cluster_5, cluster_6, cluster_7) %>%
  as_tibble() %>%
  print()
```

Calculate the condition number for each expression matrix and create the signature matrix
```{r}
# create a list of expression matrices and filter by union genes
exp_subsetter <- function(gene_vect){
  cluster_exp_df %>%
    dplyr::filter(gene_name %in% gene_vect) %>%
    as.data.frame() %>%
    column_to_rownames(var = "gene_name") %>%
    as.matrix()
}

g_expr_mat_list <- map(g_genes_union, exp_subsetter)
map(g_expr_mat_list, dim)
str(g_expr_mat_list)

condition_numbers <- map_dbl(g_expr_mat_list, kappa) %>% 
  enframe() %>%
  mutate(gval = gsub("gvalue_", "", name)) %>%
  mutate(gval = as.numeric(gval)) %>%
  dplyr::filter(gval > 24) %>%
  print()

ggplot(data = condition_numbers, aes(x = gval, y = value)) +
  geom_point() +
  geom_line() +
  ylab("Condition Number") +
  xlab("G-value")

condition_numbers %>% arrange(value) %>% print()
# condition number for gvalue 36 is a significant local minimum and will be chosen 

sig_matrix <- g_expr_mat_list[["gvalue_33"]]

# get descriptive statistics
# G = 33
dim(sig_matrix)
# 325 genes
kappa(sig_matrix)
```

#### Compare signature matrix to established macrophage gene sets

Read in LM22 from: https://cibersortx.stanford.edu/download.php

```{r}
lm22 <- read_delim("data/LM22.txt", "\t", 
    escape_double = FALSE, trim_ws = TRUE)

lm22_genes <- pull(lm22, `Gene symbol`)
mac_sig_matrix_genes <- rownames(sig_matrix)

venn.diagram(x = list(lm22_genes, mac_sig_matrix_genes),
             category.names = c("LM22 Signature Genes" , 
                                "Macrophage Cluster \nSignature Genes"),
             filename = "output/venn.png",
             output = TRUE ,
             imagetype = "png",
             height = 600, 
          width = 600, 
          resolution = 300,
          compression = "lzw",
          lwd = 1.5,
          col = c("red", "blue"),
          fill = c(alpha("red", 0.3), alpha("blue", 0.3)),
          cex = 1.1,
          fontfamily = "sans",
          cat.cex = 0.5,
          cat.default.pos = "outer",
          cat.pos = c(-5, 5),
          cat.dist = c(0.055, 0.09),
          cat.fontfamily = "sans",
          cat.col = c("red", "blue")) %>%
  print()
```

#### Format signature matrix for CIBERTSORTx

```
Reference sample file format:
Tab-delimited tabular input format (.txt) with no double quotations and no missing entries. 

Gene symbols in column 1; Reference cell phenotype labels in row 1.

Cells with the same phenotype should have the same phenotypic label.

Remove any non-assigned cells before uploading the file to CIBERSORTx.

CIBERSORTx will automatically normalize the input data such that the sum of all normalized reads are the same for each transcriptome. If a gene length-normalized expression matrix is provided (e.g., RPKM), then the signature matrix will be in TPM (transcripts per million). If a count matrix is provided, the signature matrix will be in CPM (counts per million). Regardless of the input, the signature matrix and mixture files should be represented in the same normalization space.

Data should be in non-log space. Note: if maximum expression value is <50; CIBERSORTx will assume that data are in log space, and will anti-log all expression values by 2x.
```

```{r}
# needs to be in linear, not log format
# log2 values were generated from import from raw lumi data, along with RSN normalization
# will anti-log the data to return to linear space
# expression matrix filtered for protein expression above:
exp_mat[1:5, 1:5]
linear_exp <- 2^(exp_mat)
linear_exp[1:5, 1:5]

cluster_lookup <- pheno_data[, c("raw_id", "adj_cluster")]

linear_exp_tbl <- linear_exp %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column(var = "raw_id") %>%
  as_tibble() %>%
  left_join(cluster_lookup) %>%
  dplyr::select(adj_cluster, everything(), -raw_id) %>%
  dplyr::filter(adj_cluster != "cluster_0") %>%
  print()

lin_cluster_matrix <- linear_exp_tbl[-1] %>% as.matrix()
lin_cluster_matrix[1:5, 1:5]
rownames(lin_cluster_matrix) <- pull(linear_exp_tbl, adj_cluster)
lin_cluster_matrix[1:5, 1:5]

# normalize matrix by cpm
lin_cluster_cpm <- cpm(lin_cluster_matrix)

# collapse rownames by averaging expression for shared cluster assignment
lin_cluster_cpm <- avereps(lin_cluster_cpm) %>% t()
lin_cluster_cpm[1:5, 1:5]
dim(lin_cluster_cpm)

# filter for signature genes
lin_cluster_df <- lin_cluster_cpm %>%
  as.data.frame() %>%
  rownames_to_column(var = "GeneSymbol") %>%
  as_tibble() %>%
  dplyr::filter(GeneSymbol %in% mac_sig_matrix_genes) %>%
  print()

# read out for use in CIBERSORTx
lin_cluster_df %>% write_tsv("output/lin_cluster_signature_matrix.tsv")
```

## Signature matrix: LM22 + mac spectrum 

Load source document - hand assembled in Excel from literature source and database search using GEO web application. B-cell signatures excluded to ensure validity in DLBCL samples. Housekeeping genes, highly expressed solid tumor genes, and highly expressed DLBCL genes excluded from signature matrix.

```{r}
masterlist <- read_csv("~/dlbcl_landscape/data/cibersort/sig_mat_pheno_data.csv") %>%
  print()

dataset_list <- masterlist %>%
  pull(dataset) %>%
  unique() %>%
  as.list() %>%
  # last gse is macrophage illumina dataset - will handle separately
  .[1:9] %>%
  print()
```


#### Blacklist

From: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5998872/

Chen SH, Kuo WY, Su SY, Chung WC, Ho JM, Lu HH, Lin CY. A gene profiling deconvolution approach to estimating immune cell composition from complex tissues. BMC Bioinformatics. 2018 May 8;19(Suppl 4):154. doi: 10.1186/s12859-018-2069-6. PMID: 29745829; PMCID: PMC5998872.


```
To define a set of feature genes for deconvolution, we first eliminate genes that are unsuitable for building model. Two methods were adopted. We use datasets and enrichment score (ES) described in Benita et al. [13] to define genes that expressed in normal tissues by the criteria of ES>0 in more than 5% of observed tissue types. Besides, genes that expressed in cancer cells are collected from cancer cell line encyclopedia [14] in the criteria of log2 transformed expression level>7. The two lists are used as black lists to remove genes expressed in normal tissues and cancer cells from the candidate list.
```

For this project, we will use the list of housekeeping genes from: 
"Human housekeeping genes revisited" E. Eisenberg and E.Y. Levanon, Trends in Genetics, 29 (2013) as the first filter. List of housekeeping genes downloaded from author's website: https://www.tau.ac.il/~elieis/HKG/


```{r}
hk_genes <- read_delim("/Volumes/kline-lab/backups/tcga_macs/data/HK_genes.tsv", 
                       delim = "\t", 
                       col_names = c("hgnc_name", "refseq_name"), 
                       trim_ws = TRUE)
hk_genes

blacklist_hk_genes <- hk_genes %>%
  pull(hgnc_name)
head(blacklist_hk_genes)
length(blacklist_hk_genes)
```

Broad Cancer Cell Line Encyclopedia (CCLE) RNAseq gene expression data for 1019 cell lines (raw read counts) downloaded from website: www.broadinstitute.org/ccle. Version last updated: Jan 2, 2019
File moved to data folder

For this project, only genes highly expressed in DLBCL will be included in the blacklist

```{r}
# read in as matrix
ccle <- CePa::read.gct("/Volumes/kline-lab/backups/tcga_macs/data/CCLE_RNAseq_genes_counts_20180929.gct")
dim(ccle)

# read in annotation file
ccle_annotation <- read_delim("~/dlbcl_landscape/data/CCLE_sample_info_file_2012-10-18.txt", 
    "\t", escape_double = FALSE, trim_ws = TRUE) %>%
  dplyr::select(ccle_name = `CCLE name`, site = `Site Primary`, histology = Histology, hist_subtype = `Hist Subtype1`) %>%
  print()

# select DLBCL cell lines only
ccle_dlbcl_lines <- ccle_annotation %>%
  dplyr::filter(grepl("lymphoma", hist_subtype)) %>%
  dplyr::filter(grepl("diffuse_large_B_cell", hist_subtype)) %>%
  pull(ccle_name) %>%
  print()

# filter for dlbcl cell lines
ccle_dlbcl <- ccle %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_id") %>%
  dplyr::select(one_of(ccle_dlbcl_lines), gene_id) %>%
  as_tibble() %>%
  print()

# remove hematopoetic cancer cell lines
ccle_non_heme <- ccle %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_id") %>%
  dplyr::select(!contains("HAEMATOPOIETIC_AND_LYMPHOID_TISSUE")) %>%
  as_tibble() %>%
  print()

# add columns back together
ccle_combined <- ccle_non_heme %>%
  left_join(ccle_dlbcl) %>%
  column_to_rownames(var = "gene_id") %>%
  as.matrix()

dim(ccle_combined)
ccle_combined[1:5, 1:5]

# log transform
log2_ccle <- log2(ccle_combined)

# read in gene_id to gene_name conversion table
gencode_gtf <- read_tsv("/Volumes/kline-lab/backups/tcga_macs/data/gencode.v22.primary_assembly.annotation.gtf.geneinfo") %>%
  separate(gene_id, into = c("gene_id", "version"), sep = "\\.") %>%
  dplyr::select(gene_id, gene_name) %>%
  print()

# get average gene expression across all cancer cell lines
ccle_log_means <- rowMeans(log2_ccle, na.rm = FALSE, dims = 1)
hist(ccle_log_means)
cancer_genes_high <- ccle_log_means[ccle_log_means > 12]
length(cancer_genes_high)
hist(cancer_genes_high)
head(cancer_genes_high)
blacklist_ccle_genes <- names(cancer_genes_high) %>% 
  enframe() %>%
  dplyr::select(gene_id = value) %>%
  separate(gene_id, into = c("gene_id", "version"), sep = "\\.", remove = TRUE) %>%
  left_join(gencode_gtf) %>%
  dplyr::filter(!is.na(gene_name)) %>%
  pull(gene_name)
head(blacklist_ccle_genes)
length(blacklist_ccle_genes)
```

Make combined blacklist
```{r}
blacklist <- unique(c(blacklist_ccle_genes, blacklist_hk_genes))
length(blacklist)
head(blacklist)
```


#### Cluster

```
Data from the 22 cell types (the signature set, 113 arrays) are quantile normalized before detecting differentially expressed genes. In order to prevent the datasets containing bias experiment result, clustering on gene profiling is applied. The clustering method is complete linkage and in the Euclidean distance. The inconsistency of gene profiling clusters and cell type labels is further analyzed for an advanced outlier judgment. 
```

Read in pre-processed expression matrix for datasets in masterlist, previously assembled. See ~/dlbcl_landscape/analysis/new_signature_matrix.Rmd for assembly of raw data from GEO.

Annotation from expressionset containing pre-processed expression data: 

```
CEL files downloaded where available for each dataset and background corrected following annotation in phenodata (RMA for Affymetrix and RSN for Illumina chips). GSE3982 had no available CEL files and was downloaded as MAS5 normalized data which was then log2 transformed to match RMA. Individual samples chosen as representative populations and assigned to groups by hand after literature review. Summarized at gene level with HGNC gene names. Probes that did not map to a gene name were dropped and duplicate gene names averaged. Combined into single expression matrix in log2 space.
```

```{r filter}
# expression set created above
# contains background-corrected data
# also contains metadata from GEO and cell type assignment
# expression in terms of hugo gene names
es_preprocessed <- readRDS("~/dlbcl_landscape/preprocessed_data_for_signature_matrix_es.rds")

# retreive preprocessed expression data
expr_preprocessed <- exprs(es_preprocessed)
summary(as.factor(expr_preprocessed < 0))
summary(expr_preprocessed)
summary(as.factor(is.na(expr_preprocessed)))
# negative numbers can be introduced by RMA normalization if probe intensity is lower than the background probes - this will be addressed with an offset
# NAs are probably introduced by different gene coverage of the various different probesets and should be removed
expr_pre <- expr_preprocessed %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_id") %>%
  as_tibble() %>%
  drop_na() %>%
  as.data.frame() %>%
  column_to_rownames(var = "gene_id") %>%
  as.matrix()
summary(as.factor(expr_pre < 0))
summary(expr_pre)
summary(as.factor(is.na(expr_pre)))
expr_pre[expr_pre < 0] <- 0.01
expr_pre[expr_pre == 0] <- 0.01
summary(as.factor(expr_pre < 0))
summary(expr_pre)
summary(as.factor(is.na(expr_pre)))
range(expr_pre)

# quantile normalize using limma function
expr_norm <- limma::normalizeBetweenArrays(expr_pre, 
                                           method = "quantile")

summary(as.factor(expr_norm < 0))
summary(as.factor(is.na(expr_norm)))
range(expr_norm)

## Clustering gene expression to examine phenotype labels
set.seed(818)

# select 1000 highest probes with highest variation
# input is normalized expression matrix with zero expression genes removed
myvars <- apply(expr_norm, 1, var, na.rm = TRUE) 
myvars <- sort(myvars, decreasing = TRUE) 
myvars <- myvars[1:1000] 
expr_onek <- expr_norm[names(myvars), ] 
dim(expr_onek) 

cell_type <- as.numeric(as.factor(pData(es_preprocessed)$abreviated_name))
```

```{r}
# heirarchical cluster
dend <- t(expr_onek) %>% 
  scale() %>% 
  dist() %>% 
  hclust(method = "ward.D2") %>% 
  as.dendrogram() %>%
  color_branches(clusters = cell_type) %>%
  set("labels", pData(es_preprocessed)$abreviated_name)
plot(dend)

ggd1 <- as.ggdend(dend)
ggplot(ggd1)

dend2 <- t(expr_onek) %>% 
  scale() %>% 
  dist() %>% 
  hclust(method = "ward.D2") %>% 
  as.dendrogram() %>%
  color_branches(clusters = cell_type) %>%
  set("labels", rownames(pData(es_preprocessed)))
plot(dend2)

ggd2 <- as.ggdend(dend2)
ggplot(ggd2)

# suggested pdf size 36"w x 30"h
```

```{r}
# subset the data to remove the CD8 naive group (cannot be separated from CD8 T-effector cells) and the out-of-place T-regs enveloped by neutrophils
# done by hand in excel spreadsheet for masterlist
# so now it shows up at the start of the notebook... time travel
pheno_data_subset <- masterlist %>%
  dplyr::filter(!is.na(cell_type)) %>%
  print()

keep_cases <- pheno_data_subset %>%
  pull(sample_id)
dim(expr_norm)
expr_norm_subset <- expr_norm[, keep_cases]
dim(expr_norm_subset)
```

Now will remove blacklist genes
```
To define a set of feature genes for deconvolution, we first eliminate genes that are unsuitable for building model. Two methods were adopted.
```

```{r}
dim(pheno_data_subset)

expr_norm_subset_filtered_df <- expr_norm_subset %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_name") %>%
  as_tibble() %>%
  dplyr::filter(!gene_name %in% blacklist) %>%
  print()
expr_norm_subset_filtered <- expr_norm_subset_filtered_df[-1] %>%
  as.matrix()
rownames(expr_norm_subset_filtered) <- expr_norm_subset_filtered_df$gene_name

expr_norm_subset_filtered[1:5, 1:5]
dim(expr_norm_subset_filtered)
```

Filter genes by protein expression
```{r}
# tidy data
edata_tbl <- expr_norm_subset_filtered %>% 
  as.data.frame() %>%
  rownames_to_column(var = "gene_name") %>%
  as_tibble() %>%
  gather(key = "sample_id", value = "intensity", -gene_name) %>%
  group_by(sample_id)

# find "valley" in density plot for low value filtering
dplot <- ggplot(edata_tbl, aes(intensity, color = sample_id)) +
  geom_density() + 
  theme(legend.position = "none") +
  geom_vline(xintercept = 4)
dplot

# remove any probes without at least expression value 4 in at least 3 samples (smallest group)
dataMatrix <- as.data.frame(expr_norm_subset_filtered)
mat_stats <- data.frame(total = apply(dataMatrix, 1, function(x) sum(
      x > 4, na.rm = TRUE)))
keep = which(mat_stats$total >= 3) 

dim(dataMatrix)
selDataMatrix = dataMatrix[keep,] %>% as.matrix()
dim(selDataMatrix)

# gather list of selected probes
geneList <- rownames(selDataMatrix)

# get phenodata for groups
dim(pheno_data_subset)
```

#### Differential gene expression

From:
Chen SH, Kuo WY, Su SY, Chung WC, Ho JM, Lu HH, Lin CY. A gene profiling deconvolution approach to estimating immune cell composition from complex tissues. BMC Bioinformatics. 2018 May 8;19(Suppl 4):154. doi: 10.1186/s12859-018-2069-6. PMID: 29745829; PMCID: PMC5998872.

```
To select genes that can be the representative features of a cell type, we run the statistical analysis between each two immune cell type pairs. Firstly, the differentially expressed genes (DEGs) are detected using two-sided unequal variance T-test with a significant criterion in q-value <0.3. Secondly, we sort the DEGs of each comparing pair by the absolute value of log fold change of gene expression level in descending order. Third, a top G (G=5 to 100) ranked DEGs are selected from each pair to build a union set of a signature gene list (top G signature gene list) and to derive top G signature matrix, the expression profiles for each top G signature gene list. Condition number [15] which is associated with the linear equation is introduced to define the choice of G and calculated with “kappa” function in R.
```

Development of LM22 from CIBERSORT paper:

Newman AM, Liu CL, Green MR, Gentles AJ, Feng W, Xu Y, Hoang CD, Diehn M, Alizadeh AA. Robust enumeration of cell subsets from tissue expression profiles. Nat Methods. 2015 May;12(5):453-7. doi: 10.1038/nmeth.3337. Epub 2015 Mar 30. PMID: 25822800; PMCID: PMC4739640.
```
We obtained GEP data from the public domain for 22 leukocyte subsets profiled on the HGU133A platform (Supplementary Table 1). Probesets were preprocessed as described above. Significantly differentially expressed genes between each population and all other populations were identified using a two-sided unequal variance t-test. Genes with a q-value < 0.3 (false discovery rate29) were considered significant.

For each leukocyte subset, significant genes were ordered by decreasing fold change compared to other cell subsets, and the top G marker genes from each cell subset were combined into a signature matrix BG. We iterated G from 50 to 200 across all subsets, and retained the signature matrix with the lowest condition number (condition number = 11.4; G = 102; n = 547 distinct genes; Supplementary Table 1).

To prevent genes expressed on non-hematopoietic cell types from confounding deconvolution results, we also used two gene filtration strategies. First, we identified genes with enriched expression in non-hematopoietic cells or tissues using the Gene Enrichment Profiler, an online compendium of diverse cells and tissues profiled on HGU133A (http://xavierlab2.mgh.harvard.edu/EnrichmentProfiler/)30. Gene Enrichment Profiler calculates an enrichment score (ES) for a given gene in a given cell or tissue type based on the sum of linear model coefficients from all pairwise comparisons of that gene with other samples. For each gene and cell or tissue type with ES > 0, we determined the fraction of non-hematopoietic cell or tissue samples in the Gene Enrichment Profiler database, and excluded genes from the signature matrix with a non-hematopoietic fraction >0.05. As a second filtration step, we omitted all genes from further analysis with a mean log2 expression level ≥7 in all non-hematopoietic cancer cell lines profiled in the Cancer Cell Line Encyclopedia (CCLE) (pre-normalized gene expression data were extracted from CCLE_Expression_Entrez_2012-09-29.txt, downloaded from the Broad Institute). We termed the final signature matrix ‘LM22’.
```

Summary of plan:

*Step 1:* Get DEGs of each cluster compaired pairwise to others using limma. Select only those genes with adj.P.Val > 0.3 for each comparison.
*Step 1b:* Apply blacklist and remove housekeeping and cancer genes from list

*Step 2:* Sort each comparison's ttable by logFC in descending order

*Step 3:*. For each G value from 25-200, make an vector of the top G genes from each comparison. Filter the expression matrix for only those genes and create a list of 95 expression matrices (one for each value of G). Calculate the condition number for each expression matrix using the `kappa` function and choose the one with the lowest condition number. This will be the signature gene list.
*Step 3b:* Create the signature gene matrix by averaging columns by each cluster and filtering rows by the signature gene list.

#### Step 1 and 2

```{r}
# set up design matrix
rnames <- rownames(pheno_data_subset)
groups <- as.factor(pheno_data_subset$cell_type)
batch <- as.factor(pheno_data_subset$platform_code)
design <- model.matrix(~0 + groups)
colnames(design) <- gsub("groups", "", colnames(design))
rownames(design) <- rnames
head(design)

# make contrasts
unique_groups <- as.character(unique(groups))
unique_groups

# get permutations
conts <- as.data.frame(permutations(n = length(unique_groups), r = 2, v = unique_groups)) %>%
  mutate(cont = paste0(V1, "-", V2)) %>%
  pull(cont)
conts
  
# define contrasts
contr.matrix <- makeContrasts(contrasts = conts, levels = design)
contr.matrix[1:5, 1:5]
dim(contr.matrix)

# fit linear models
fit <- lmFit(selDataMatrix, design)
fit2 <- contrasts.fit(fit, contr.matrix)
fit2 <- eBayes(fit2)

# make a list from to length of conts
numlist <- as.list(seq(1, length(conts)))

# define a function to get toptables and combine in a list
toptabler <- function(numlist, fit){
  topTable(fit2, coef = numlist, 
           adjust.method = "BH",
           sort.by = "none",
           number = Inf)
}

# iterate function over number list
ttables <- map(numlist, toptabler)
head(ttables[[1]])

# define a funtion to get selected columns from toptables
maketables <- function(ttable_list){
  ttable_list %>%
    rownames_to_column(var = "gene_name") %>%
    dplyr::select(gene_name, logFC, adj.P.Val) %>%
    as_tibble() %>%
    # select only those with adj.P.Val < 0.3
    dplyr::filter(adj.P.Val < 0.3) %>%
    # filter against the blacklist
    dplyr::filter(!gene_name %in% blacklist) %>%
    # sort by logFC
    arrange(desc(logFC)) %>%
    # remove any unnamed genes
    dplyr::filter(!is.na(gene_name)) %>%
    # remove duplicates
    distinct(gene_name, .keep_all = TRUE)
}

# apply function to list of toptables
tables <- map(ttables, maketables)
tables[[1]]
names(tables) <- conts
head(tables)
# convert to nested dataframe
table_df <- enframe(tables)
table_df
```

#### Step 3

```{r}
# use for loop to slice dataframe column 195 times from 5:200
for (g in 5:200) {
  new_col_name <- paste0("gvalue_", g)
  table_df <- table_df %>%
    mutate(!!sym(new_col_name) := map(value, 
                                      function(x){dplyr::slice(x, 1:{g})}))
}

# get just the g columns and get the gene names
# convert to list
g_genes <- table_df %>%
  dplyr::select(starts_with("gvalue_")) %>%
  mutate_all(~map(., function(x){dplyr::select(x, gene_name)})) %>%
  mutate_all(~map(., unlist)) %>%
  map(., unlist) 
str(g_genes)

# get unique values only
g_genes_union <- map(g_genes, unique)
str(g_genes_union)
```

#### Step 3b

Format expression matrix
```{r}
# average expression by cell type
cell_type_lookup <- pheno_data_subset[, c("sample_id", "cell_type")]

exp_tbl <- selDataMatrix %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column(var = "sample_id") %>%
  as_tibble() %>%
  left_join(cell_type_lookup) %>%
  dplyr::select(cell_type, everything(), -sample_id) %>%
  print()

cluster_matrix <- exp_tbl[-1] %>% as.matrix()
cluster_matrix[1:5, 1:5]
rownames(cluster_matrix) <- pull(exp_tbl, cell_type)
cluster_matrix[1:5, 1:5]

# collapse rownames by averaging expression for shared cluster assignment
cluster_matrix <- avereps(cluster_matrix) %>% t()
cluster_matrix[1:5, 1:5]
dim(cluster_matrix)

# convert to df for downstream analysis
cluster_exp_df <- cluster_matrix %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_name") %>%
  as_tibble() %>%
  print()
```

Calculate the condition number for each expression matrix and create the signature matrix
```{r}
# create a list of expression matrices and filter by union genes
exp_subsetter <- function(gene_vect){
  cluster_exp_df %>%
    dplyr::filter(gene_name %in% gene_vect) %>%
    as.data.frame() %>%
    column_to_rownames(var = "gene_name") %>%
    as.matrix()
}

g_expr_mat_list <- map(g_genes_union, exp_subsetter)
map(g_expr_mat_list, dim)
str(g_expr_mat_list)

condition_numbers <- map_dbl(g_expr_mat_list, kappa) %>% 
  enframe() %>%
  mutate(gval = gsub("gvalue_", "", name)) %>%
  mutate(gval = as.numeric(gval)) %>%
  print()

ggplot(data = condition_numbers, aes(x = gval, y = value)) +
  geom_point() +
  geom_line() +
  ylab("Condition Number") +
  xlab("G-value")

condition_numbers %>% arrange(value) %>% print()
# condition number for gvalue 22 is a significant local minimum and will be chosen 

sig_matrix <- g_expr_mat_list[["gvalue_22"]]

# get descriptive statistics
# G = 22
dim(sig_matrix)
# 964 genes
kappa(sig_matrix)
```

#### Compare signature matrix to established gene sets

Read in LM22 from: https://cibersortx.stanford.edu/download.php

```{r}
lm22 <- read_delim("/Volumes/kline-lab/backups/tcga_macs/data/LM22.txt", "\t", 
    escape_double = FALSE, trim_ws = TRUE)

lm22_genes <- pull(lm22, `Gene symbol`)
spectrum_sig_matrix_genes <- rownames(sig_matrix)

venn.diagram(x = list(lm22_genes, spectrum_sig_matrix_genes),
             category.names = c("LM22 Signature Genes" , 
                                "Spectrum Custom \nSignature Genes"),
             filename = "output/venn.png",
             output = TRUE ,
             imagetype = "png",
             height = 600, 
          width = 600, 
          resolution = 300,
          compression = "lzw",
          lwd = 1.5,
          col = c("red", "blue"),
          fill = c(alpha("red", 0.3), alpha("blue", 0.3)),
          cex = 1.1,
          fontfamily = "sans",
          cat.cex = 0.5,
          cat.default.pos = "outer",
          cat.pos = c(-5, 5),
          cat.dist = c(0.055, 0.09),
          cat.fontfamily = "sans",
          cat.col = c("red", "blue"))

```

#### Format signature matrix for CIBERTSORTx

```
Reference sample file format:
Tab-delimited tabular input format (.txt) with no double quotations and no missing entries. 

Gene symbols in column 1; Reference cell phenotype labels in row 1.

Cells with the same phenotype should have the same phenotypic label.

Remove any non-assigned cells before uploading the file to CIBERSORTx.

CIBERSORTx will automatically normalize the input data such that the sum of all normalized reads are the same for each transcriptome. If a gene length-normalized expression matrix is provided (e.g., RPKM), then the signature matrix will be in TPM (transcripts per million). If a count matrix is provided, the signature matrix will be in CPM (counts per million). Regardless of the input, the signature matrix and mixture files should be represented in the same normalization space.

Data should be in non-log space. Note: if maximum expression value is <50; CIBERSORTx will assume that data are in log space, and will anti-log all expression values by 2x.
```

```{r}
# needs to be in linear, not log format
# log2 values were generated from import from raw lumi data, along with RSN normalization
# will anti-log the data to return to linear space
# expression matrix filtered for protein expression above:
expr_norm_subset[1:5, 1:5]
linear_exp <- 2^(expr_norm_subset)
linear_exp[1:5, 1:5]

cell_type_lookup <- pheno_data_subset[, c("sample_id", "cell_type")]

linear_exp_tbl <- linear_exp %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column(var = "sample_id") %>%
  as_tibble() %>%
  left_join(cell_type_lookup) %>%
  dplyr::select(cell_type, everything(), -sample_id) %>%
  print()

lin_cluster_matrix <- linear_exp_tbl[-1] %>% as.matrix()
rownames(lin_cluster_matrix) <- pull(linear_exp_tbl, cell_type)
lin_cluster_matrix[1:5, 1:5]
# normalize matrix by cpm
lin_cluster_cpm <- cpm(t(lin_cluster_matrix))
lin_cluster_cpm[1:5, 1:5]
# collapse rownames by averaging expression for shared cluster assignment
lin_cluster_ave <- avereps(t(lin_cluster_cpm))
lin_cluster_ave[1:5, 1:5]
dim(lin_cluster_ave)
lin_cluster_rot <- t(lin_cluster_ave)
lin_cluster_rot[1:5, 1:5]
dim(lin_cluster_rot)
# filter for signature genes
lin_cluster_df <- lin_cluster_rot %>%
  as.data.frame() %>%
  rownames_to_column(var = "GeneSymbol") %>%
  as_tibble() %>%
  dplyr::filter(GeneSymbol %in% dlbcl_sig_matrix_genes) %>%
  print()

# read out for use in CIBERSORTx
lin_cluster_df %>% write_tsv("output/lm22_plus_spectrum_final_signature_matrix.tsv")
```


## Create Reference File
```
The reference sample file is an input file required for custom signature genes file generation by CIBERSORT and consists of a table of the gene expression profiles of reference sample cell populations that will be compared to each other as defined in the phenotype classes file to generate the custom signature genes file.

Reference file formatting requirements. Improperly formatted files may cause CIBERSORTx to fail to run.

Tab-delimited tabular input format (.txt) with no double quotations and no missing entries.
Gene symbols in column 1; Reference cell population labels in row 1. Replicate populations can have the same label.
It is highly recommended that replicate population columns be placed adjacent to each other, as this will make it easier for you to create your phenotype classes file.
Gene symbols should be of the same type as those used in the Mixture file. For example, if HUGO symbols were used in the Mixture file, HUGO symbols should also be used for the reference sample file. Non-HUGO symbols can be used so long as they are used in both the Mixture and reference sample files.
We strongly recommend 50% or greater overlap in genes between the mixture and signature genes files. If the overlap is less than 50%, this may affect performance and accuracy.
Data should be in non-log space. Note: if maximum expression value is <50; CIBERSORTx will assume that data are in log space, and will anti-log all expression values by 2x.

```

```{r}
# needs to be in linear, not log format
# log2 values were generated from import from raw lumi data, along with RSN normalization
# will anti-log the data to return to linear space
# expression matrix filtered for protein expression above:
expr_norm_subset[1:5, 1:5]
linear_exp <- 2^(expr_norm_subset)
linear_exp[1:5, 1:5]

cell_type_lookup <- pheno_data_subset[, c("sample_id", "cell_type")]

linear_exp_tbl <- linear_exp %>%
  t() %>%
  as.data.frame() %>%
  rownames_to_column(var = "sample_id") %>%
  as_tibble() %>%
  left_join(cell_type_lookup) %>%
  dplyr::select(cell_type, everything(), -sample_id) %>%
  print()

lin_cluster_matrix <- linear_exp_tbl[-1] %>% as.matrix()
rownames(lin_cluster_matrix) <- pull(linear_exp_tbl, cell_type)
lin_cluster_matrix[1:5, 1:5]
# normalize matrix by cpm
lin_cluster_cpm <- cpm(t(lin_cluster_matrix))
lin_cluster_cpm[1:5, 1:5]
# collapse rownames by averaging expression for shared cluster assignment
lin_cluster_ave <- avereps(t(lin_cluster_cpm))
lin_cluster_ave[1:5, 1:5]
dim(lin_cluster_ave)
lin_cluster_rot <- t(lin_cluster_ave)
lin_cluster_rot[1:5, 1:5]
dim(lin_cluster_rot)
line_cluster_df <- lin_cluster_rot %>%
  as.data.frame() %>%
  rownames_to_column(var = "GeneSymbol") %>%
  as_tibble() %>%
  print()

write_delim(line_cluster_df, "output/lm22_plus_spectrum_reference_matrix_file.tsv", delim = "\t")
```


## Format TCGA Expression Matrix

```{r}
# read in tcga data
tcga_total <- read_csv("output/selected.total.counts.csv", trim_ws = TRUE) 

# read in dlbcl data
dlbcl_total <- read_csv("output/nci_dlbcl_unprocessed_counts.csv", trim_ws = TRUE)

# make a list
raw_counts <- list(tcga_total, dlbcl_total)

# read in conversion table for gene IDs
gencode_gtf <- read_tsv("data/gencode.v22.primary_assembly.annotation.gtf.geneinfo")


# and change to hugo gene names
renamer <- function(dataframe) {
  df1 <- dataframe %>%
    dplyr::rename(gene_id = gene) %>%
    left_join(gencode_gtf) %>%
    dplyr::filter(gene_type == "protein_coding") %>%
    dplyr::select(gene_name, everything()) %>%
    dplyr::select(-gene_id, -gene_type, -gene_status, -gene_id, -level, -havana_gene) %>%
    as.data.frame()
}

# apply function to list
hugo_counts <- map(raw_counts, renamer)
names(hugo_counts) <- c("TCGA", "DLBCL")

# look at the head
map(hugo_counts, function(x){x[1:5, 1:5]})

# define a function to convert to cpm matrix
# filter for protein coding genes only
cpmer <- function(df){
  df_mat <- df[-1] %>% as.matrix()
  rownames(df_mat) <- df %>% pull(gene_name)
  # average expression for repeated gene names
  # convert to CPM
  df_mat %>%
    avereps() %>%
    cpm()
}

# apply function to list
cpm_counts <- map(hugo_counts, cpmer)

# look at the head
map(cpm_counts, function(x){x[1:5, 1:5]})

# convert to single matrix for TMM normalization
cpm_dfs <- map(cpm_counts, function(mat){
  mat %>%
    as.data.frame() %>%
    rownames_to_column(var = "gene_name") %>%
    as_tibble()
})

cpm_dfs

total_matrix <- cpm_dfs[["TCGA"]] %>%
  left_join(cpm_dfs[["DLBCL"]]) %>%
  as.data.frame() %>%
  column_to_rownames(var = "gene_name") %>%
  as.matrix()

# get normalization factors (EdgeR)
norm_factors <- calcNormFactors(total_matrix, method = "TMM")
summary(norm_factors)

# convert expression matrix to dataframe
total_matrix_df <- as.data.frame(total_matrix)

# apply factor to each column
total_cpm_norm <- map2_dfc(total_matrix_df, norm_factors, `*`)
total_cpm_norm <- as.data.frame(total_cpm_norm)
rownames(total_cpm_norm) <- rownames(total_matrix_df)
total_cpm_norm[1:5, 1:5]
str(total_cpm_norm)

# split matrix into smaller subunits due to file size limits on CIBERSORTx
# there is a file quota of 1000 MB
# also ran up against a memory limitation when I tried quarters (4 subsets)
# needs to be tsv with gene names in column 1, every column with a name
# example is named "GeneSymbol"
length(colnames(total_cpm_norm))
eighths <- 10090 / 8
eighths
cutpoints <- c(1, 1261, 2522, 3783, 5045, 6306, 7567, 8828, 10090)

subset_list <- list("subset1" = total_cpm_norm[, 1:1261], 
                    "subset2" = total_cpm_norm[, 1262:2522], 
                    "subset3" = total_cpm_norm[, 2523:3783], 
                    "subset4" = total_cpm_norm[, 3784:5045],
                    "subset5" = total_cpm_norm[, 5046:6306],
                    "subset6" = total_cpm_norm[, 6307:7567],
                    "subset7" = total_cpm_norm[, 7568:8828],
                    "subset8" = total_cpm_norm[, 8829:10090])

subset_dfs <- subset_list %>%
  map(., function(x) as.data.frame(x)) %>%
  map(., function(x) rownames_to_column(x, var = "GeneSymbol")) 

write_delim(subset_dfs[[1]], 
            "output/cibersort_expression_matrix_sub1.tsv",
            delim = "\t",
            col_names = TRUE)

write_delim(subset_dfs[[2]], 
            "output/cibersort_expression_matrix_sub2.tsv",
            delim = "\t",
            col_names = TRUE)

write_delim(subset_dfs[[3]], 
            "output/cibersort_expression_matrix_sub3.tsv",
            delim = "\t",
            col_names = TRUE)

write_delim(subset_dfs[[4]], 
            "output/cibersort_expression_matrix_sub4.tsv",
            delim = "\t",
            col_names = TRUE)

write_delim(subset_dfs[[5]], 
            "output/cibersort_expression_matrix_sub5.tsv",
            delim = "\t",
            col_names = TRUE)

write_delim(subset_dfs[[6]], 
            "output/cibersort_expression_matrix_sub6.tsv",
            delim = "\t",
            col_names = TRUE)

write_delim(subset_dfs[[7]], 
            "output/cibersort_expression_matrix_sub7.tsv",
            delim = "\t",
            col_names = TRUE)

write_delim(subset_dfs[[8]], 
            "output/cibersort_expression_matrix_sub8.tsv",
            delim = "\t",
            col_names = TRUE)
```

## Format IMTX Expression Matrix
Read in data
```{r}
# Will import raw counts and metadata only
# Datasets provided by R. Bao. Downloaded 7/1/2019.

# Riaz
riaz_counts <- read_tsv("data/IMTX_datasets/riaz/Riaz.rnaseq.kallisto.raw.txi.txt") %>%
  tidyr::separate(X1, sep = "!", into = c("gene_symbol", "geneID_split")) %>%
  dplyr::select(-gene_symbol) %>%
  print()

# Hugo
hugo_counts <- read_tsv("data/IMTX_datasets/hugo/Hugo.rnaseq.kallisto.raw.txi.txt") %>%
  tidyr::separate(X1, sep = "!", into = c("gene_symbol", "geneID_split")) %>%
  dplyr::select(-gene_symbol) %>%
  print()

# Gide
gide_counts <- read_tsv("data/IMTX_datasets/gide/Gide.rnaseq.kallisto.raw.txi.txt") %>%
  tidyr::separate(X1, sep = "!", into = c("gene_symbol", "geneID_split")) %>%
  dplyr::select(-gene_symbol) %>%
  print()

countlist <- list(riaz_counts, hugo_counts, gide_counts)
names(countlist) <- c("riaz_counts", "hugo_counts", "gide_counts")
str(countlist)
# list of three tibbles with similar structure (different samples)
# one column containing gene_ids, multiple columns containing raw read counts, rows are genes

```

Convert gene names to GENCODE v22 gene ids to match GDC standard
```{r}
# read in conversion table for gene IDs
gencode_gtf <- read_tsv("data/gencode.v22.primary_assembly.annotation.gtf.geneinfo")

# gencode gene IDS without decimal version numbers are given for count identifiers
# GDC standard is gencode v22, which is source of NCI data
# will convert to gencode v22 to match rows of NCI data
geneID_split <- str_split(gencode_gtf$gene_id, pattern = "\\.", simplify = TRUE) %>% 
  as_tibble() %>%
  dplyr::select(geneID_split = V1)

gencode_gtf_split <- gencode_gtf %>% 
  bind_cols(geneID_split) %>%
  dplyr::select(gene_id_v22 = gene_id, geneID_split, everything()) %>%
  print()

# Define function to convert gene names to gencode v22
# Filter for protein-coding genes only
# Remove any features that do not have a corresponding v22 gene ID
translate_geneids <- function(df){
  df_filt <- left_join(df, gencode_gtf_split) %>%
    dplyr::select(gene_name, geneID_split, gene_type, everything()) %>%
    dplyr::select(-gene_status, -gene_id_v22, -level, -havana_gene) %>%
    dplyr::filter(gene_type == "protein_coding") %>%
    dplyr::select(-gene_type, -geneID_split)
  df_filt
}

countlist_protcode_gencodev22 <- map(countlist, translate_geneids)
str(countlist_protcode_gencodev22)

```

#### Convert to a single matrix

Add in urothelial data from bladder cancer TGF-beta expression immunotherapy cohort study ([see notebook](urothelial.html))

```{r}
# prepare urothelial data for joining
blad_expr_matrix <- readRDS("output/blad_expr_matrix.rds")
dim(blad_expr_matrix)
blad_expr_matrix[1:5, 1:5]
str(blad_expr_matrix)

blad_expr <- blad_expr_matrix %>%
  as.data.frame() %>%
  rownames_to_column(var = "gene_id_v22") %>%
  as_tibble() %>%
  print()

blad_expr_hugo <- translate_geneids(blad_expr)

# prepare melanoma expression counts for joining
list2env(countlist_protcode_gencodev22, envir = .GlobalEnv)

# join tables
combined_counts <- riaz_counts %>%
  left_join(hugo_counts) %>%
  left_join(gide_counts) %>%
  left_join(blad_expr_hugo)
str(combined_counts) 

# convert to matrix
expr_imtx_mat <- combined_counts[-1] %>% as.matrix()
rownames(expr_imtx_mat) <- pull(combined_counts, gene_name)
library(limma)
expr_imtx_hugo <- avereps(expr_imtx_mat)
expr_imtx_hugo[1:5, 1:5]
str(expr_imtx_hugo)
expr_imtx[1:5, 1:5]
summary(as.factor(is.na(expr_imtx_hugo)))
summary(as.factor(expr_imtx_hugo < 0))

# replace nas with 0
expr_imtx_hugo[is.na(expr_imtx_hugo)] <- 0
summary(as.factor(is.na(expr_imtx_hugo)))
summary(as.factor(expr_imtx_hugo < 0))
```

#### Convert to CPM
```{r}
# correct for library size with cpm using EdgeR
expr_imtx_cpm <- cpm(expr_imtx_hugo, log = FALSE)
str(expr_imtx_cpm)
expr_imtx_cpm[1:5, 1:5]
```

#### Initial density plots
```{r}
# Density plots
# tidy data
tidy_cpm <- t(expr_imtx_cpm) %>%
  as.data.frame() %>%
  rownames_to_column(var = "sample_id") %>%
  as_tibble() %>%
  gather(key = "gene_id", value = "intensity", -sample_id) %>%
  print()

# plots
dplot_imtx <- ggplot(tidy_cpm, aes(intensity)) +
  geom_density() + 
  theme(legend.position = "none")
dplot_imtx +
  xlim(-5, 20)

# plot with log and small offset
dplot_imtx_log <- ggplot(tidy_cpm, aes(log(intensity + 0.5))) +
  geom_density() + 
  theme(legend.position = "none")
dplot_imtx_log +
  xlim(-10, 10)

```

#### Filtering by expression
```{r}
# apply hard cutoffs
# cpm expression cutoff: 1
cutoff <- 1
# must be expressed in at least: half
min_sm_frac <- 0.5
filter_frac <- min_sm_frac * ncol(expr_imtx_cpm)
filter_frac
total_cpm_stats <- data.frame(
  total = apply(expr_imtx_cpm, 1, function(x){
    sum(x > cutoff, na.rm = TRUE)
    } ))
keep <- which(total_cpm_stats$total >= filter_frac)

# convert to data frame for subsetting
expr_imtx_cpm_df <- expr_imtx_cpm %>% as.data.frame()

# check results
dim(expr_imtx_cpm_df)
expr_imtx_cpm_filtered <- expr_imtx_cpm_df[keep,]
dim(expr_imtx_cpm_filtered)
```

#### Post-filtering density plots

```{r}
# Density plots
# tidy data
tidy_cpm_filtered <- t(expr_imtx_cpm_filtered) %>%
  as.data.frame() %>%
  rownames_to_column(var = "sample_id") %>%
  as_tibble() %>%
  gather(key = "gene_id", value = "intensity", -sample_id) %>%
  print()

# plots
dplot_imtx_2 <- ggplot(tidy_cpm_filtered, aes(intensity)) +
  geom_density() + 
  theme(legend.position = "none")
dplot_imtx_2 +
  xlim(-5, 20)

# plot with log and small offset
dplot_imtx_log_2 <- ggplot(tidy_cpm_filtered, aes(log(intensity + 0.5))) +
  geom_density() + 
  theme(legend.position = "none")
dplot_imtx_log_2 +
  xlim(-10, 10)
```

#### Normalize gene expression distributions

Normalization by the method of trimmed mean of M-values (TMM) is performed using the calcNormFactors function in edgeR. The normalisation factors calculated here are used as a scaling factor for the library sizes. 

```{r}
# get normalization factors
norm_factors <- calcNormFactors(expr_imtx_cpm_filtered, method = "TMM")

# convert expression matrix to dataframe
expr_imtx_cpm_df <- as.data.frame(expr_imtx_cpm_filtered)

# apply factor to each column
imtx_cpm_norm <- map2_dfc(expr_imtx_cpm_df, norm_factors, `*`)
imtx_cpm_norm <- as.data.frame(imtx_cpm_norm)
rownames(imtx_cpm_norm) <- rownames(expr_imtx_cpm_filtered)
imtx_cpm_norm[1:5, 1:5]
```

Convert to TSV for CIBERSORTx
```{r}
imtx_cpm_tsv <- imtx_cpm_norm %>%
  as.data.frame() %>%
  rownames_to_column(var = "GeneSymbol") %>%
  write_delim(., "output/cibersort_imtx_matrix.tsv", 
              delim = "\t", 
              col_names = TRUE)


```

## Results

First read in absolute results of Van Allen melanoma dataset with LM22 and my mac clusters

```{r}
vallen_lm22 <- read_delim("output/cibersort_results/absolute_fractions/van_allen_lm22/CIBERSORTx_Job2_Results.txt", 
                          delim = "\t", 
                          col_names = TRUE)

vallen_mac <-  read_delim("output/cibersort_results/absolute_fractions/van_allen_macs/CIBERSORTx_Job1_Results.txt", 
                          delim = "\t", 
                          col_names = TRUE)

v_lm22_plot <- vallen_lm22 %>%
  dplyr::select(Mixture, 
                Monocytes, 
                M0_macrophages = `Macrophages M0`,
                M1_macrophages = `Macrophages M1`,
                M2_macrophages = `Macrophages M2`) %>%
  gather(key = cell_type, value = score, -Mixture) %>%
  ggplot(aes(x = cell_type, y = score, fill = cell_type)) +
    geom_boxplot() +
  labs(title = "Van Allen Melanoma Dataset",
       subtitle = "LM22 macrophage cell types") +
  xlab("") +
  ylab("Absolute deconvolution score") +
  theme_classic2() +
  scale_fill_viridis(discrete = TRUE) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1))
v_lm22_plot

v_mac_plot <- vallen_mac %>%
  dplyr::select(Mixture, 
                C1 = cluster_1,
                C2 = cluster_2,
                C3 = cluster_3,
                C4 = cluster_4,
                C5 = cluster_5,
                C6 = cluster_6,
                C7 = cluster_7) %>%
  gather(key = cell_type, value = score, -Mixture) %>%
  ggplot(aes(x = cell_type, y = score, fill = cell_type)) +
    geom_boxplot() +
    labs(title = "Van Allen Melanoma Dataset",
       subtitle = "Novel macrophage clusters") +
  xlab("") +
  ylab("Absolute deconvolution score") +
  theme_classic2() +
  scale_fill_viridis(discrete = TRUE) +
  theme(axis.text.x = element_text(angle = 60, hjust = 1))
v_mac_plot
```

Read in pancancer relative deconvolution results
```{r}
subset_1 <- read_delim("output/cibersort_results/relative_fractions/subset_1/CIBERSORTx_Job1_Results.txt", 
                          delim = "\t", 
                          col_names = TRUE)

subset_2 <- read_delim("output/cibersort_results/relative_fractions/subset_2/CIBERSORTx_Job2_Results (1).txt", 
                          delim = "\t", 
                          col_names = TRUE)

subset_3 <- read_delim("output/cibersort_results/relative_fractions/subset_3/CIBERSORTx_Job1_Results.txt", 
                          delim = "\t", 
                          col_names = TRUE)

subset_4 <- read_delim("output/cibersort_results/relative_fractions/subset_4/CIBERSORTx_Job2_Results.txt", 
                          delim = "\t", 
                          col_names = TRUE)

subset_5 <- read_delim("output/cibersort_results/relative_fractions/subset_5/CIBERSORTx_Job1_Results (1).txt", 
                          delim = "\t", 
                          col_names = TRUE)

subset_5 <- read_delim("output/cibersort_results/relative_fractions/subset_5/CIBERSORTx_Job1_Results (1).txt", 
                          delim = "\t", 
                          col_names = TRUE)

subset_6 <- read_delim("output/cibersort_results/relative_fractions/subset_6/CIBERSORTx_Job2_Results (3).txt", 
                          delim = "\t", 
                          col_names = TRUE)

subset_7 <- read_delim("output/cibersort_results/relative_fractions/subset_7/CIBERSORTx_Job4_Results.txt", 
                          delim = "\t", 
                          col_names = TRUE)

subset_8 <- read_delim("output/cibersort_results/relative_fractions/subset_8/CIBERSORTx_Job1_Results (2).txt", 
                          delim = "\t", 
                          col_names = TRUE)

pancan_relative_cibersort <- bind_rows(subset_1, subset_2, subset_3, subset_4, subset_5, subset_6, subset_7, subset_8) %>%
  print()

# convert to tidy format for plotting
decon_tidy <- pancan_relative_cibersort %>% 
  dplyr::rename(sampleID = Mixture) %>%
  dplyr::select(-`P-value`, -Correlation, -RMSE) %>%
  gather(key = "cluster", value = "score", -sampleID) %>%
  # create and clean up group variable
  mutate(group = str_sub(sampleID, 1, 4)) %>%
  mutate(group = ifelse(grepl("^GBM*", group), "GBM", group)) %>%
  mutate(group = ifelse(grepl("^OV*", group), "OV", group)) %>%
  mutate(group = ifelse(grepl("^LGG*", group), "LGG", group)) %>%
  mutate(group = ifelse(grepl("^UVM*", group), "UVM", group)) %>%
  mutate(group = ifelse(grepl("^UCS*", group), "UCS", group)) %>%
  mutate(group = ifelse(grepl("^ACC*", group), "ACC", group)) %>%
  mutate(group = as.factor(group)) %>%
  # refactor cluster variable
  mutate(cluster = fct_recode(cluster,
                              "C1" = "cluster_1",
                              "C2" = "cluster_2",
                              "C3" = "cluster_3",
                              "C4" = "cluster_4",
                              "C5" = "cluster_5",
                              "C6" = "cluster_6",
                              "C7" = "cluster_7")) %>%
  mutate(cluster = as.character(cluster)) %>%
  print()

saveRDS(decon_tidy, "output/relative_deconvolution_tidy.rds")

dlbcl_decon <- decon_tidy %>%
  dplyr::filter(group == "DLBC") %>%
  ggplot(aes(x = cluster, y = score, fill = cluster)) +
    geom_boxplot() +
    labs(title = "DLBCL") +
    xlab("") +
    ylab("Relative deconvolution score") +
    theme_classic2() +
    scale_fill_viridis(discrete = TRUE) +
    theme(axis.text.x = element_text(angle = 60, hjust = 1))
dlbcl_decon

paad_decon <- decon_tidy %>%
  dplyr::filter(group == "PAAD") %>%
  ggplot(aes(x = cluster, y = score, fill = cluster)) +
    geom_boxplot() +
    labs(title = "PAAD") +
    xlab("") +
    ylab("Relative deconvolution score") +
    theme_classic2() +
    scale_fill_viridis(discrete = TRUE) +
    theme(axis.text.x = element_text(angle = 60, hjust = 1))
paad_decon
```

Individual heatmaps
```{r}
decon_tidy_nest <- decon_tidy %>% 
  tidyr::nest(data = c(cluster, sampleID, score)) %>%
  print()

decon_tidy_list <- decon_tidy_nest$data %>% as.list()
names(decon_tidy_list) <- decon_tidy_nest$group

# review results
decon_tidy_list

# function to convert format for heatmap
EnterTheMatrix <- function(df){
  mat <- df %>%
    tidyr::spread(., key = "sampleID", value = "score") %>%
    as.data.frame() %>%
    column_to_rownames(var = "cluster") %>%
    as.matrix()
  mat
}

# apply function to list of dataframes
mat_list <- map(decon_tidy_list, EnterTheMatrix)

# quick check of mat_list format
mat_list[[1]][, 1:5]

# function for making heatmap from supplied matrix
makeheatmap <- function(mat, mat_names){
  ha <- rowAnnotation(score = anno_histogram(mat, n_breaks = 10))
  ht <- Heatmap(mat, name = "CIBERSORTx \nScore", 
                row_title = "",
                show_row_names = TRUE,
                row_names_side = "left",
                column_title = mat_names, 
                show_column_names = FALSE,
                show_column_dend = FALSE,
                show_row_dend = FALSE,
                column_title_side = "top",
                right_annotation = ha)
  ht}

# apply function to list of matrices
mat_names <- names(mat_list)
listofheatmaps <- map2(mat_list, mat_names, makeheatmap)
names(listofheatmaps) <- names(mat_list)

listofheatmaps[["DLBC"]]
listofheatmaps[["PAAD"]]
```

Summary heatmap
```{r}
ave_scores <- decon_tidy %>%
  group_by(group, cluster) %>%
  summarize(mean_exp = mean(score)) %>%
  tidyr::spread(key = cluster, value = mean_exp) %>%
  as.data.frame() %>%
  column_to_rownames(var = "group") %>%
  as.matrix() %>%
  t()

library(seriation)
set.seed(818)
o1 = seriate(dist(ave_scores), method = "TSP") %>% get_order()
o2 = seriate(dist(t(ave_scores)), method = "TSP") %>% get_order()

# print heatmap

hm <- Heatmap(ave_scores, 
              name = "Mean \nCIBERSORTx \nScore", 
              row_order = o1, 
              column_order = o2,
              cluster_columns = FALSE,
              cluster_rows = FALSE,
              use_raster = FALSE)
hm

# width = 8, height = 3
```
